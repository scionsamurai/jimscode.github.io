# TypeScript Basics: Understanding Core Types and Concepts

## 1. Introduction to Type Systems
- Understanding static vs dynamic typing
- TypeScript's type system philosophy
- Type safety and its benefits
- Type annotations vs type inference

## 2. Basic Types Deep Dive
### Number Type
- Integer and floating-point numbers
- Special numeric values (NaN, Infinity)
- Numeric literals and separators
- Number vs number

### String Type
- Single vs double quotes
- Template literals
- String methods and type safety
- String concatenation best practices

### Boolean Type
- Truthy and falsy values
- Boolean operators
- Common boolean patterns
- Boolean assertions

## 3. Working with Arrays
- Array type notation
- Array methods and type safety
- Readonly arrays
- Array spread and rest operations
- Multi-dimensional arrays
- Array iteration with types

## 4. Understanding Tuples
- Tuple type syntax
- Fixed-length arrays
- Optional tuple elements
- Tuple type inference
- Common use cases
- Destructuring tuples

## 5. Objects and Interfaces
- Object type notation
- Interface declarations
- Optional properties
- Readonly properties
- Extended interfaces
- Index signatures
- Implementing interfaces

## 6. Working with Enums
- Numeric enums
- String enums
- Heterogeneous enums
- Const enums
- Reverse mappings
- Best practices and common patterns
- When to use enums vs union types

## 7. Type Inference Deep Dive
- How TypeScript infers types
- Contextual typing
- Best practices for letting TypeScript infer
- When to explicitly declare types
- Common inference pitfalls
- Type widening and narrowing

## 8. Type Assertions
- Type assertion syntax
- The 'as' keyword
- Non-null assertions
- Safe type assertions
- Double assertions
- When to use assertions
- Alternatives to type assertions

## 9. Special Types
- any and unknown
- void and never
- undefined and null
- object vs Object
- When to use each type

## 10. Type Compatibility
- Structural typing explained
- Assignability rules
- Fresh vs stale objects
- Excess property checks
- Type compatibility with classes and interfaces

## 11. Practical Examples and Best Practices
- Common type patterns
- Type organization strategies
- Naming conventions
- Documentation practices
- Code examples for each concept
- Exercise suggestions
