<!doctype html>
<html lang="en-US" id="top-of-site">
 <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Unravel the complexities of Rust Enums and Pattern Matching in this in-depth exploration. Enhance your programming arsenal and gain confidence in handling diverse data structures for system-level tasks.">
  <meta name="author" content="Jimmy Ruikka">
  <title>Rust Enums - JimsCode</title>
<script src='/txt/js/highlight.js'>
  </script>
  <link rel='stylesheet' href='/txt/css/monokaisublime.css' type="text/css">
<script>
hljs.highlightAll();  </script>
<script src='/txt/js/post.js'>
  </script>
<script src='/txt/js/site_funcs.js'>
  </script>
<script src='/txt/js/site_variables.js'>
  </script>
<script>
window.addEventListener('load', function() {
                var script = document.createElement('script');
                script.src = '/txt/js/ongenerated.js';
                document.body.appendChild(script);
              });  </script>
<script>
window.addEventListener('load', function() {
            var script = document.createElement('script');
            script.textContent = "setupTabs();addHeaderListeners();window.addEventListener('scroll', highlightActiveHeader);closeShareLinks(); updateCopyLinks();";
            document.body.appendChild(script);
          });  </script>
  <link rel='stylesheet' href='/txt/css/global.css' type="text/css">
  <link rel='stylesheet' href='/txt/css/post.css' type="text/css">
  <link rel='stylesheet' href='/txt/css/footer.css' type="text/css">
  <link rel='stylesheet' href='/txt/css/tabbedinfo.css' type="text/css">
  <link rel='stylesheet' href='/txt/css/flipcard.css' type="text/css">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="manifest" href="/images/site.webmanifest">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-HKH81XKEQN">
   </script>
<script>
window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-HKH81XKEQN');   </script>
  </head>
  <body>
   <input class="nodisplay" type="checkbox" id="sidebar_checkbox">
   <input class="nodisplay" type="radio" id="night" name="themecolor" value="night" onclick="updateThemeCache">
   <input onclick="updateThemeCache" class="nodisplay" type="radio" id="day" name="themecolor" value="day" checked="checked">
   <div class="wrapper">
    <div id="lsi29rb3uq">
<span role="navigation" style="display:flex; background: var(--primary); justify-content: space-between; padding: 1rem 0; position: relative; z-index: 5; width: 100vw; min-height: 1.2rem;" class="navbar" id="navID" data-original-css="display:flex; background: var(--primary); justify-content: space-between; padding: 1rem 0; position: relative; z-index: 5; width: 100vw; min-height: 1.2rem;">     <div style="padding: 0 8px;" class="name-and-icon" data-original-css="padding: 0 8px;">
      <div class="sidebar_checkbox_hack">
       <label for="sidebar_checkbox" onclick="window.scrollTo(0,0)" class="sidebar_button pointer">       <p class="emoji_active_memo">Back to Post</p>
       <img src="/images/favicon-32x32.png" alt="Jims emoji icon">
</label>
      </div>
 <a href="/" style="text-decoration: none;" class="home-link" data-original-css="text-decoration: none;"><span style="width: auto; margin: 0; margin-left: 2rem; font-size: 1.35rem; color: black !important;" data-original-css="width: auto; margin: 0; margin-left: 2rem; font-size: 1.35rem; color: black !important;">Jims Code Blog</span></a>      </div>
     <div role="search" style="margin: auto 2rem auto 0;" class="navbar_right" id="search_area" data-original-css="margin: auto 2rem auto 0;">
      <form method="get" action="http://www.google.com/search" class="no-js-search">
       <input type="text" name="q" size="15" class="no-js-search__input" id="search">
       <button type="submit" value="Search!" class="no-js-search__button">
Search       </button>
       <input type="checkbox" name="sitesearch" value="jimscode.blog" checked="" style="display: none;" class="no-js-search__checkbox" data-original-css="display: none;">
      </form>
     </div>
</span>     <div class="color-pallete">
      <label for="night"></label>
      <label for="day"></label>
     </div>
     <div style="position: fixed;" id="star-area" data-original-css="position: fixed;">
     </div>
 <a href="#top-of-site" aria-label="Scroll to top" onclick="window.scrollTo(0,0)" onkeypress="if(event.keyCode===13){window.scrollTo(0,0)}" tabindex="0" style="background: var(--font-color); position: fixed; bottom: 2rem; left: 1rem; height: 3rem; width: 3rem; border-radius:5rem; text-align: center; z-index: 4; display: none;" class="pointer" id="arrow-div-id" data-original-css="background: var(--font-color); position: fixed; bottom: 2rem; left: 1rem; height: 3rem; width: 3rem; border-radius:5rem; text-align: center; z-index: 4; display: none;" data-conditional-scroll=" this.scrollY > 650:::display-block\|/">     <div style="width: 1rem; height: 1rem; border: solid var(--primary-clicked); border-width: 0 3px 3px 0; margin-top: 1rem;" class="up arrow" id="backToTopArrow" data-original-css="width: 1rem; height: 1rem; border: solid var(--primary-clicked); border-width: 0 3px 3px 0; margin-top: 1rem;">
     </div>
     <p style="display: none;" id="TopArrowText" data-original-css="display: none;">Back to top</p>
</a>     </div>
    <div id="lsi29rb3j2">
     <div style="min-height: 20rem" class="banner-div" data-original-css="min-height: 20rem">
      <div class="banner">
      </div>
     </div>
     <div role="main" class="main-content">
      <div class="post-container">
       <div class="post">
        <h1 style="display: inline-flex; justify-content: space-around; text-align: center;" class="threedtext" data-original-css="display: inline-flex; justify-content: space-around; text-align: center;">Mastering Enums and Pattern Matching in Rust: A System Developer's Guide</h1>
        <p style="font-size: 0.95rem;" data-original-css="font-size: 0.95rem;">Published: Sun, Feb 11 2024 22:07:02 GMT</p>
        <picture class="banner_picture" id="lsi29rb7pu">
         <source srcset="/images/rust-enums-banner.webp" type="image/webp" class="banner-image">
          <source srcset="/images/rust-enums-banner-png.png" type="image/png" class="banner-image">
           <img src="" alt="Sectioned image with different seasons in each section." class="banner-image">
          </picture>
          <br>
          <div id="lsi29rb7y3">
<span id="lsi29rbi0o">           <br>
           <h2 id="Introduction-to-Enums-in-Rust" class="pointer">Introduction to Enums in Rust<span class="anchor-image">⚓</span></h2>
           <br>
           <p>Enums are a powerful feature in Rust that allow you to define custom data types to represent a fixed set of possible values. Think of them like supercharged version of enums in other languages - they can store data and behavior associated with each variant.</p>
           <br>
           <p>In this section we'll learn:</p>
           <ul class="ul_class">
            <li>How to define and use basic enums in Rust</li>
            <li>Different ways to associate data with enum variants</li>
            <li>How pattern matching makes working with enums easy</li>
            <li>How enums relate to other major features like structs and error handling</li>
           </ul>
           <br>
           <p>So let's dive in and see how enums can help you write clean, scalable Rust programs!</p>
           <br>
           <h3>Declaring Enums</h3>
           <br>
           <p>Declaring an enum is easy - just use the <span class="special_quote">enum</span> keyword:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbsvl">enum WebEvent {
     PageLoad,
     Click,
     KeyPress(char),
     Paste(String),
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>Enum variants can optionally have data associated with them. For example, the <span class="special_quote">KeyPress</span> variant here contains a <span class="special_quote">char</span> .</p>
           <br>
           <p>You can also specify explicit discriminant values for each variant:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbsa7">enum Number {
     Zero = 0,
     One = 1,
     Two = 2
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>But usually allowing Rust to assign default values is fine.</p>
           <br>
           <h3>Creating Enum Instances</h3>
           <br>
           <p>Once an enum is declared, we can create instances by specifying the variant we want:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbsho">let page_load = WebEvent::PageLoad;
 
 let key_press = WebEvent::KeyPress('x');</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>If a variant has associated data, we provide that data when creating an instance:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbs3b">let paste_event = WebEvent::Paste("Some text".to_string());</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>Enum instances are statically typed - the compiler knows this is a <span class="special_quote">WebEvent</span> :</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbs0t">fn log(event: WebEvent) {
     // ...
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>So enums allow you to define custom data types and safely use them in your code.</p>
           <br>
           <h2 id="Implementing-Methods-on-Enums" class="pointer">Implementing Methods on Enums<span class="anchor-image">⚓</span></h2>
           <br>
           <p>In addition to storing data, we can also implement methods directly on enums to encapsulate behavior for each variant.</p>
           <br>
           <p>For example:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbs6w">enum WebEvent {
     Click,
     KeyPress(char),
     Paste(String),
 }
 
 impl WebEvent {
     fn log(&amp;self) {
         match self {
             Self::Click =&gt; println!("Clicked"),
             Self::KeyPress(c) =&gt; println!("Key {} pressed", c),
             Self::Paste(text) =&gt; println!("Pasted: {}", text),
         }
     }
 }
 
 let event = WebEvent::KeyPress('x');
 event.log(); // Prints "Key x pressed"</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>Now we can add reusable logic that applies to all instances of an enum.</p>
           <br>
           <h3>Putting Methods to Use</h3>
           <br>
           <p>Some ways we might leverage enum methods:</p>
           <ul class="ul_class">
            <li>Common formatting/output logic</li>
            <li>Validation checking</li>
            <li>Helper calculations/transformations</li>
            <li>Integration with external services</li>
           </ul>
           <br>
           <p>Methods help encapsulate behavior related to enums in one tidy place!</p>
           <br>
           <h2 id="Associated-Data" class="pointer">Associated Data<span class="anchor-image">⚓</span></h2>
           <br>
           <p>We've seen basic associated data with enums like this:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbsx7">enum WebEvent {
     KeyPress(char),
     Paste(String),
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>But we can also use more complex types like structs and tuples:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbt8s">struct PasteData {
     text: String,
     source_app: String,
 }
 
 enum WebEvent {
     Paste(PasteData),
 }
 
 let event = WebEvent::Paste(PasteData {
     text: "example text".to_string(),
     source_app: "Notes".to_string(),
 });</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>This allows us to bundle related data with enum variants.</p>
           <br>
           <h2 id="Tuple-and-Struct-Enums" class="pointer">Tuple and Struct Enums<span class="anchor-image">⚓</span></h2>
           <br>
           <p>We can also use tuples and structs directly as enum variants:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbtzl">enum Color {
     Rgb(u8, u8, u8),
     Hsv(u8, u8, u8)
 }
 
 enum Shape {
     Circle { radius: f64 },
     Rect { width: f64, height: f64 }
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>Tuples are great for simple related values, and structs allow us to name the associated values.</p>
           <br>
           <p>This helps eliminate duplication - we don't need a separate <span class="special_quote">Circle</span> struct anymore, for example.</p>
           <br>
           <h2 id="Introduction-to-Pattern-Matching" class="pointer">Introduction to Pattern Matching<span class="anchor-image">⚓</span></h2>
           <br>
           <p>Pattern matching allows us to inspect an enum instance and take different actions depending on which variant it is. Here's an example:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbtnp">fn inspect(event: WebEvent) {
     match event {
         WebEvent::PageLoad =&gt; println!("Page loaded"),
         WebEvent::Paste(text) =&gt; println!("Pasted: {}", text),
         _ =&gt; ()
     }
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>The <span class="special_quote">match</span> expression checks the <span class="special_quote">event</span> value against the different patterns we specify - almost like a switch statement in other languages.</p>
           <br>
           <p>This allows us to handle each enum variant differently in a concise, exhaustive way.</p>
           <br>
           <h2 id="Matching-Enum-Variants" class="pointer">Matching Enum Variants<span class="anchor-image">⚓</span></h2>
           <br>
           <p>Let's look closer at matching variants:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbtlr">enum WebEvent {
     Click,
     KeyPress(char),
 }
 
 fn inspect(event: WebEvent) {
     match event {
         WebEvent::Click =&gt; {
             // Handle click
         },
         WebEvent::KeyPress(c) =&gt; {
             // Handle key press of character c
         },
     }
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>We can directly match against each variant, and any associated data is extracted for us to use!</p>
           <br>
           <p>This avoids messy conditional logic, and the compiler ensures every variant is handled.</p>
           <br>
           <p>Matching enums is essential for modeling complex systems efficiently and safely in Rust.</p>
           <br>
           <h3>Using Non-Exhaustive Patterns</h3>
           <br>
           <p>When matching enum variants, we can also use a catch-all <span class="special_quote">_</span> pattern to handle multiple variants at once:</p>
           <br>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbtps">fn inspect(event: WebEvent) {
     match event {
         WebEvent::KeyPress(c) =&gt; {
             println!("Pressed {}", c)
         }
         _ =&gt; {
           println!("Some other event")
         }
     }
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>This <span class="special_quote">_</span> pattern will match any <span class="special_quote">WebEvent</span> that isn't a <span class="special_quote">KeyPress</span> .</p>
           <br>
           <p>We can specify multiple non-exhaustive patterns:</p>
           <br>
           <br>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbu5q">match event {
     WebEvent::Paste(_) | WebEvent::Click =&gt; {
         // Handle pastes and clicks
     }
     _ =&gt; { /* Other events */ }
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>It's best practice to have a catch-all pattern so that any new variants added later don't break functionality.</p>
           <br>
           <p>The compiler will warn us about truly non-exhaustive matches without a <span class="special_quote">_</span> fallback.</p>
           <br>
           <p>While handling variants individually is ideal, non-exhaustive patterns are useful for simplifying logic across multiple variants when needed.</p>
           <br>
           <h2 id="Destructuring-Enum-Variants" class="pointer">Destructuring Enum Variants<span class="anchor-image">⚓</span></h2>
           <br>
           <p>Pattern matching allows us to destructure enums to extract their internal data:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbuz7">enum Shape {
     Rectangle { width: u32, height: u32 },
     Circle(u32),
 }
 
 fn inspect(shape: Shape) {
     match shape {
         Shape::Rectangle { width, height } =&gt; {
             println!("A rectangle with dimensions {} x {}", width, height);
         },
         Shape::Circle(radius) =&gt; {
             println!("A circle with radius {}", radius);
         }
     }
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>Instead of using the whole <span class="special_quote">Rectangle</span> variant, we match on just the <span class="special_quote">width</span> and <span class="special_quote">height</span> fields. This avoids repetitive code.</p>
           <br>
           <p>Destructuring works similarly for tuple variants:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbuqk">fn rgb_to_hex(color: (u8, u8, u8)) {
     match color {
         (r, g, b) =&gt; {
             println!("{}{}{}", r, g, b); // convert to hex
         }
     }
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <h2 id="Matching-Complex-Enums" class="pointer">Matching Complex Enums<span class="anchor-image">⚓</span></h2>
           <br>
           <p>We can match enums with complex associated data too:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbuo0">enum Event {
     MouseClick { x: i64, y: i64 },
     KeyPress(char),
 }
 
 fn inspect(event: Event) {
     match event {
         Event::MouseClick { x, y } =&gt; {
             println!("Clicked at x:{}, y:{}", x, y);
         },
         Event::KeyPress(c) =&gt; {
             println!("Key pressed: {}", c);
         }
     }
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>This flexibility helps model intricate domains cleanly.</p>
           <br>
           <p>So destructuring and nested matching makes working with elaborate enums concise and easy!</p>
           <br>
           <h2 id="Using-Pattern-Matching-in-Conditional-Statements" class="pointer">Using Pattern Matching in Conditional Statements<span class="anchor-image">⚓</span></h2>
           <br>
           <p>In addition to <span class="special_quote">match</span> expressions, we can also use pattern matching within <span class="special_quote">if let</span> and <span class="special_quote">while let</span> conditional statements.</p>
           <br>
           <p>For example:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbv55">enum Shape {
     Circle(u32),
     Rectangle(u32, u32)
 }
 
 fn print_shape(shape: Shape) {
     if let Shape::Circle(radius) = shape {
         println!("Circle with radius {}", radius);
     } else if let Shape::Rectangle(width, height) = shape {
         println!("Rectangle with dimensions {} x {}", width, height);
     }
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>The <span class="special_quote">if let</span> checks if <span class="special_quote">shape</span> matches the <span class="special_quote">Circle</span> variant, extracting the radius. A similar approach works for <span class="special_quote">while let</span> .</p>
           <br>
           <p>This can be cleaner than cascaded <span class="special_quote">match</span> statements when we only need to check one variant at a time.</p>
           <br>
           <h2 id="Looping-with-Pattern-Matching" class="pointer">Looping with Pattern Matching<span class="anchor-image">⚓</span></h2>
           <br>
           <p>We can also use pattern matching variants directly in loops:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbv6l">let shapes = vec![Shape::Circle(3), Shape::Rectangle(4, 5)];
 
 for shape in shapes {
     match shape {
         Shape::Circle(radius) =&gt; println!("Radius {}", radius),
         Shape::Rectangle(width, height) =&gt; {
             println!("{} x {}", width, height);
         }
     }
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>So pattern matching is useful well beyond <span class="special_quote">match</span> expressions!</p>
           <br>
           <p>Leveraging it in conditionals and loops helps simplify control flow when working with enums.</p>
           <br>
           <h3>Looping While an Option Has a Value</h3>
           <br>
           <p>We can also use <span class="special_quote">while let</span> to loop over an option enum as long as it has a value:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbvts">let mut events = Some(vec![WebEvent::Click]);
 
 // Loop while events has some value
 while let Some(e) = events {
     match e.pop() {
         Some(event) =&gt; {
             event.log(); // Log event
         }
         None =&gt; {
             events = None; // No more events
         }
     }
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>This constructs a loop that:</p>
           <br>
           <p>1. Checks if <span class="special_quote">events</span> matches <span class="special_quote">Some(e)</span> , binding the vector to <span class="special_quote">e</span> </p>
           <p>2. Pops off an event from the vector</p>
           <p>3. Logs the event if there was one</p>
           <p>4. Sets <span class="special_quote">events</span> to <span class="special_quote">None</span> when empty to exit</p>
           <br>
           <p>We could expand this to fetch new batches of events to keep the loop going.</p>
           <br>
           <p>The <span class="special_quote">Option</span> enum allows this style of looping over a value that may or may not be present.</p>
           <br>
           <p>So while let bindings are very useful for processing option enums!</p>
           <br>
           <h2 id="Creating-Complex-Data-Structures" class="pointer">Creating Complex Data Structures<span class="anchor-image">⚓</span></h2>
           <br>
           <p>We can combine enums and structs to create more intricate data models.</p>
           <br>
           <p>For example, we can represent web events happening within pages and sessions:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbv2p">struct WebSession {
     id: String,
     events: Vec&lt;WebEvent&gt;,
 }
 
 struct WebPage {
     url: String,
     sessions: Vec&lt;WebSession&gt;,
 }
 
 enum WebEvent {
     Click,
     KeyPress(char),
     Paste(String),
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>Now we can express relationships like "a key press event happened during session 123 on the homepage":</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbvgr">let home_page = WebPage {
     url: "/".to_string(),
     sessions: vec![
         WebSession {
             id: "123".to_string(),
             events: vec![
                 WebEvent::KeyPress('x')
             ]
         }
     ]
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>This composition allows us to model complex systems and hierarchies!</p>
           <br>
           <h2 id="Incorporating-Behavior-Through-Traits" class="pointer">Incorporating Behavior Through Traits<span class="anchor-image">⚓</span></h2>
           <br>
           <p>To add polymorphic behavior to such structures, we can utilize Rust's trait system.</p>
           <br>
           <p>For example, we can define a trait to encapsulate logic for logging events:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbv4z">trait Log {
     fn log(&amp;self);
 }
 
 impl Log for WebEvent {
     fn log(&amp;self) {
         match self {
             WebEvent::Click =&gt; println!("Clicked"),
             WebEvent::KeyPress(c) =&gt; println!("Key {} pressed", c),
             WebEvent::Paste(text) =&gt; println!("Pasted text: {}", text),
         }
     }
 }
 
 impl Log for WebSession {
     fn log(&amp;self) {
         println!("Session {}:", self.id);
         for event in &amp;self.events {
             event.log();
         }
     }
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>Now <span class="special_quote">WebEvent</span> and <span class="special_quote">WebSession</span> both implement the <span class="special_quote">Log</span> behavior, keeping logging code reused and maintained in one place.</p>
           <br>
           <p>We can log an entire structure:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbv0u">let session = WebSession {
     // ...
 };
 
 session.log(); // Logs session and events</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>This demonstrates how enums provide the building blocks to grow reusable, modular code in Rust!</p>
           <br>
           <h2 id="Error-Handling-with-Default-Enums" class="pointer">Error Handling with Default Enums<span class="anchor-image">⚓</span></h2>
           <br>
           <h3>Creating and Using Some and None Option Enums</h3>
           <br>
           <p>Rust's <span class="special_quote">Option</span> enum allows us to represent optional values that may or may not exist. The variants are:</p>
           <ul class="ul_class">
            <li> <span class="special_quote">Some(T)</span> : Wraps a value of type <span class="special_quote">T</span> (the option holds something)</li>
            <li> <span class="special_quote">None</span> : No value is present (the option is empty)</li>
           </ul>
           <br>
           <p>Let's look at some examples:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbva3">// User ID from a database lookup
 let user_id: Option&lt;i32&gt; = Some(5);
 
 // Results from a search query
 let search_results: Option&lt;Vec&lt;String&gt;&gt; = Some(vec![]);
 
 // Empty string parsed
 let parsed_string: Option&lt;String&gt; = None;</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>We can use <span class="special_quote">if let</span> to easily check if an Option contains data:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbv4p">if let Some(id) = user_id {
 println!("User ID: {}", id);
 }
 
 // Error - requires handling None case
 if let None = parsed_string {
     // Handle missing value
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>And <span class="special_quote">match</span> to handle both <span class="special_quote">Some</span> and <span class="special_quote">None</span> :</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbvjh">match search_results {
     Some(results) =&gt; { /* Show results */ },
     None =&gt; { /* No results */ },
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>So <span class="special_quote">Option</span> allows type-safenullable values - the compiler ensures we handle both defined and undefined states properly. This prevents bugs!</p>
           <br>
           <h3>Result and Option Enums</h3>
           <br>
           <p>Rust's standard library provides two helpful enums for error handling - <span class="special_quote">Result</span> and <span class="special_quote">Option</span> :</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbwk7">enum Result&lt;T, E&gt; {
     Ok(T),
     Err(E),
 }
 
 enum Option&lt;T&gt; {
     Some(T),
     None,
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>These express two common scenarios - an operation that may succeed ( <span class="special_quote">Ok</span> ) or fail ( <span class="special_quote">Err</span> ), and a value that may be present ( <span class="special_quote">Some</span> ) or missing ( <span class="special_quote">None</span> ).</p>
           <br>
           <p>For example, we could use them in our web event code:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbww6">fn parse_paste(text: &amp;str) -&gt; Result&lt;WebEvent, ParseError&gt; {
     // Try to parse...
     if valid {
         Ok(WebEvent::Paste(text.to_string()))
     } else {
         Err(ParseError)
     }
 }
 
 let events: Option&lt;Vec&lt;WebEvent&gt;&gt; = Some(vec![]);</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>Pattern matching on <span class="special_quote">Result</span> and <span class="special_quote">Option</span> allows clean handling of errors and missing values.</p>
           <br>
           <p>Overall they are a great demonstration of using enums for domain modeling and error handling in Rust!</p>
           <br>
           <h3>Custom Error Enums</h3>
           <br>
           <p>We can also create custom error enums for our domains:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbw5l">enum ParseEventError {
     InvalidJson,
     MissingFields,
 }
 
 enum EventSourceError {
     IoError(io::Error),
     RequestTimeout,
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>These can be used with <span class="special_quote">Result</span> to return structured errors:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbw7n">fn parse_event(json: &amp;str) -&gt; Result&lt;WebEvent, ParseEventError&gt; {
     if missing_fields {
         Err(ParseEventError::MissingFields)
     } else {
         // parse ok
         Ok(event)
     }
 }
 
 fn fetch_events() -&gt; Result&lt;Vec&lt;WebEvent&gt;, EventSourceError&gt; {
     match resp {
         Ok(resp) =&gt; {
             // parse events
         },
         Err(e) =&gt; Err(EventSourceError::IoError(e))
     }
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>Custom errors provide more context and structure than simple strings. And enums allow matching to handle errors differently:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29rbwew">match fetch_events() {
     Ok(events) =&gt; { /* use events */ },
     Err(EventSourceError::IoError(e)) =&gt; { /* retry */ },
     Err(EventSourceError::RequestTimeout) =&gt; { /* increase timeout */ },
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>So error enums are immensely useful in Rust programs!</p>
           <br>
           <h2 id="Summary-of-Enums-and-Pattern-Matching" class="pointer">Summary of Enums and Pattern Matching<span class="anchor-image">⚓</span></h2>
           <br>
           <p>Let's recap what we learned about enums:</p>
           <ul class="ul_class">
            <li>Enums allow you to define custom data types to elegantly model domains</li>
            <li>Variants can store associated data like strings, structs, etc</li>
            <li>Pattern matching is an idiomatic way to handle enums</li>
            <li>Enums combine great with other features like structs and error handling</li>
           </ul>
           <br>
           <p>Overall, Rust's enums are far more advanced than other languages. When combined with features like pattern matching they become an indispensable tool for clean system modeling and safe control flow.</p>
           <br>
           <p>Some key benefits in system programming are:</p>
           <ul class="ul_class">
            <li>Representing systemic states, errors, and resource types</li>
            <li>Enforcing validity of values at compile time</li>
            <li>Encouraging exhaustive handling of edge cases</li>
           </ul>
           <br>
           <h2 id="Exercises-and-Next-Steps" class="pointer">Exercises and Next Steps<span class="anchor-image">⚓</span></h2>
           <br>
           <p>To become proficient with enums, I recommend:</p>
           <ul class="ul_class">
            <li>Replacing duplicate structs with enum variants</li>
            <li>Modeling custom errors and results with enums</li>
            <li>Practicing pattern matching expressions and destructuring</li>
            <li>Reading user stories about enums on Rust community sites</li>
           </ul>
           <br>
           <p>Next we'll explore Rust's powerful trait system for polymorphism and abstraction. Traits allow us to extend the behavior of enums and structs in versatile ways.</p>
           <br>
           <p>But for now feel free to ask any follow up questions about enums below!</p>
           <br>
</span>          </div>
          <div style="display: flex; justify-content: space-around; margin-bottom: 1rem;" class="prev_next_buttons" data-original-css="display: flex; justify-content: space-around; margin-bottom: 1rem;">
<span style="display: block;" class="prev_button" data-original-css="display: block;"> <a href="/posts/rust-structs-lifetimes" class="btn-cta pad">Previous Post</a> </span><span style="display: none !important;" class="next_button" data-original-css="display: none !important;"> <a href="0" class="btn-cta pad">Next Post</a> </span>          </div>
          <p></p>
          <div class="giscus">
          </div>
          <p></p>
         </div>
         <div class="share-links">
          <div id="lsi29rb8wa">
           <label for="share-toggle" class="btn-cta" id="share-btn">Share <span class="share_post_text">post?</span> </label>
           <input type="checkbox" id="share-toggle">
           <ul id="share-links">
            <li style="list-style: none;" data-original-css="list-style: none;"> <a href="https://www.facebook.com/sharer/sharer.php?u=https://www.jimscode.blog/posts/rust-enums" target="_blank">Facebook</a> </li>
            <li style="list-style: none;" data-original-css="list-style: none;"> <a href="https://twitter.com/intent/tweet?url=https://www.jimscode.blog/posts/rust-enums" target="_blank">Twitter</a> </li>
            <li style="list-style: none;" data-original-css="list-style: none;"> <a href="https://www.linkedin.com/shareArticle?url=https://www.jimscode.blog/posts/rust-enums" target="_blank">LinkedIn</a> </li>
            <li style="list-style: none;" data-original-css="list-style: none;"> <a href="https://pinterest.com/pin/create/button/?url=https://www.jimscode.blog/posts/rust-enums&amp;media=https://www.jimscode.blog/images/rust-enums-banner-png.png&amp;description=mastering%20enums%20and%20pattern%20matching%20in%20rust%20a%20system%20developers%20guide" target="_blank">Pinterest</a> </li>
            <li style="list-style: none;" data-original-css="list-style: none;"> <a href="https://www.reddit.com/submit?url=https://www.jimscode.blog/posts/rust-enums" target="_blank">Reddit</a> </li>
            <li style="list-style: none;" data-original-css="list-style: none;"> <a href="whatsapp://send?text=https://www.jimscode.blog/posts/rust-enums" target="_blank">WhatsApp</a> </li>
            <li style="list-style: none;" data-original-css="list-style: none;"> <a href="mailto:?subject=mastering%20enums%20and%20pattern%20matching%20in%20rust%20a%20system%20developers%20guide&amp;body=https://www.jimscode.blog/posts/rust-enums" target="_blank">Email</a> </li>
            <li style="list-style: none;" data-original-css="list-style: none;"> <a href="https://www.instagram.com/share?url=https://www.jimscode.blog/posts/rust-enums" target="_blank">Instagram</a> </li>
           </ul>
           <br>
          </div>
         </div>
        </div>
        <aside class="sidebar">
         <br>
         <div class="about-me">
          <br>
          <div class="avatar-container">
           <img data-src="https://www.gravatar.com/avatar/26b9ca4353165489beae792f2aea7b21?s=250" alt="Avatar" class="profile-picture" src="https://www.gravatar.com/avatar/26b9ca4353165489beae792f2aea7b21?s=250">
          </div>
          <p class="large-text">About: <a class="btn-cta pad" href="/authors/jimmy-ruikka">Jimmy Ruikka</a> </p>
          <hr>
          <p style="font-size: 14px;" data-original-css="font-size: 14px;">Within the realm of technology and innovation, a passionate individual emerges! Join the creator of JimsCode.Blog as he unravels the realms of technology.</p>
         </div>
         <br>
         <div class="about-post">
          <p class="large-text">Tags</p>
          <hr>
          <ul id="lsi29rb626" style="display: contents; line-height: 2rem;">
           <li id="tagVar_rust" class="tagVar" style="display: contents; line-height: 2rem;"> <a href="/tags/rust" class="btn-cta">rust</a> </li>
           <li id="tagVar_system dev" class="tagVar" style="display: contents; line-height: 2rem;"> <a href="/tags/system%20dev" class="btn-cta">system dev</a> </li>
           <li id="tagVar_enums" class="tagVar" style="display: contents; line-height: 2rem;"> <a href="/tags/enums" class="btn-cta">enums</a> </li>
          </ul>
          <br>
         </div>
         <div class="headers">
          <div role="navigation" id="toc">
           <h3>In this article</h3>
           <hr>
           <nav aria-label="Table of Contents">
            <ul role="list">
             <li style="display: block;" role="listitem"> <a class="nav-link" tabindex="0" href="#Introduction-to-Enums-in-Rust">Introduction to Enums in Rust</a> </li>
             <hr>
             <li style="display: block;" role="listitem"> <a class="nav-link" tabindex="0" href="#Implementing-Methods-on-Enums">Implementing Methods on Enums</a> </li>
             <hr>
             <li style="display: block;" role="listitem"> <a class="nav-link" tabindex="0" href="#Associated-Data">Associated Data</a> </li>
             <hr>
             <li style="display: block;" role="listitem"> <a class="nav-link" tabindex="0" href="#Tuple-and-Struct-Enums">Tuple and Struct Enums</a> </li>
             <hr>
             <li style="display: block;" role="listitem"> <a class="nav-link" tabindex="0" href="#Introduction-to-Pattern-Matching">Introduction to Pattern Matching</a> </li>
             <hr>
             <li style="display: block;" role="listitem"> <a class="nav-link" tabindex="0" href="#Matching-Enum-Variants">Matching Enum Variants</a> </li>
             <hr>
             <li style="display: block;" role="listitem"> <a class="nav-link" tabindex="0" href="#Destructuring-Enum-Variants">Destructuring Enum Variants</a> </li>
             <hr>
             <li style="display: block;" role="listitem"> <a class="nav-link" tabindex="0" href="#Matching-Complex-Enums">Matching Complex Enums</a> </li>
             <hr>
             <li style="display: block;" role="listitem"> <a class="nav-link" tabindex="0" href="#Using-Pattern-Matching-in-Conditional-Statements">Using Pattern Matching in Conditional Statements</a> </li>
             <hr>
             <li style="display: block;" role="listitem"> <a class="nav-link" tabindex="0" href="#Looping-with-Pattern-Matching">Looping with Pattern Matching</a> </li>
             <hr>
             <li style="display: block;" role="listitem"> <a class="nav-link" tabindex="0" href="#Creating-Complex-Data-Structures">Creating Complex Data Structures</a> </li>
             <hr>
             <li style="display: block;" role="listitem"> <a class="nav-link" tabindex="0" href="#Incorporating-Behavior-Through-Traits">Incorporating Behavior Through Traits</a> </li>
             <hr>
             <li style="display: block;" role="listitem"> <a class="nav-link" tabindex="0" href="#Error-Handling-with-Default-Enums">Error Handling with Default Enums</a> </li>
             <hr>
             <li style="display: block;" role="listitem"> <a class="nav-link" tabindex="0" href="#Summary-of-Enums-and-Pattern-Matching">Summary of Enums and Pattern Matching</a> </li>
             <hr>
             <li style="display: block;" role="listitem"> <a class="nav-link" tabindex="0" href="#Exercises-and-Next-Steps">Exercises and Next Steps</a> </li>
            </ul>
           </nav>
          </div>
          <div class="affiliate">
           <h3>Affiliate links</h3>
           <p>Check out this great product: <a href="#">Product Name</a> </p>
           <div id="lsi29rbba7">
            <p>sidebar</p>
           </div>
          </div>
         </div>
        </aside>
       </div>
      </div>
      <div id="lsi29rb3dm">
       <footer role="contentinfo" style="padding: 20px; text-align: center;" data-original-css="padding: 20px; text-align: center;">
        <br>
        <br>
        <div class="footer-content">
         <div class="footer-section">
          <h4>About</h4>
          <p style="font-size: 0.9rem;" data-original-css="font-size: 0.9rem;">Embark on a coding journey with Jims Code Blog - your go-to destination for insightful tutorials, innovative projects, and the latest trends in the dynamic world of software development.</p>
         </div>
         <div class="footer-section">
          <h4>Contact</h4>
          <p>Email: admin@jimscode.blog</p>
         </div>
         <ul class="footer-section" id="lsi29rc3lo">
          <li style="list-style: none;" data-original-css="list-style: none;"> <a href="/about-us">About Us</a> </li>
          <li style="list-style: none;" data-original-css="list-style: none;"> <a href="/privacy-policy">Privacy Policy</a> </li>
          <li style="list-style: none;" data-original-css="list-style: none;"> <a href="/terms-of-service">Terms of Service</a> </li>
         </ul>
         <div class="footer-disclaimer">
          <p style="font-size: 0.82rem;" data-original-css="font-size: 0.82rem;"> <strong>Disclaimer:</strong> The information provided on this blog is for educational and informational purposes related to coding and software development. We do not guarantee the accuracy, completeness, or reliability of any information presented. Readers are encouraged to conduct their own research, practice due diligence, and consult with professionals for coding-related decisions and implementation.</p>
         </div>
         <div class="footer-bottom">
          <p>Portions of this website use <a href="https://highlightjs.org">highlight.js</a> , © 2023 Jims Code Blog</p>
         </div>
        </div>
       </footer>
      </div>
<style>
@media only screen and (max-width : 1350px) and (min-width : 950px) {
#arrow-div-id{ right: 2.2rem; left: unset !important;}
}

@media only screen and (max-width : 750px) {
#arrow-div-id{ display: none !important;}#lsi29rc3lo{ font-size: 0.9rem; display: flex; justify-content: space-between; padding: 5px 0 5px 0;}
}

@media only screen and (max-width : 1350px) {
#TopArrowText{ right: 1rem;}
}

@media only screen and (min-width : 1px) {
#lsi29rb7pu{ display: block;}#lsi29rb626{ display: block;}
}

@media only screen and (min-width : 750px) {
#lsi29rc3lo{ display: flex; flex-direction: column;}
}      </style>
     </div>
<script>
toggle_nightmode();loadThemeCache();generateSearchElements('search_area'); updateComments();     </script>
<script>
let giscusTheme = localStorage.getItem("theme");
        let giscusAttributes = {
          "src": "https://giscus.app/client.js",
          "data-repo": "scionsamurai/jimscode.github.io",
          "data-repo-id": "R_kgDOK8_rSw",
          "data-category": "Announcements",
          "data-category-id": "DIC_kwDOK8_rS84Cb9LP",
          "data-mapping": "pathname",
          "data-strict": "1",
          "data-reactions-enabled": "1",
          "data-emit-metadata": "0",
          "data-theme": giscusTheme && giscusTheme == "night" ? "noborder_gray" : "noborder_light",
          "data-lang": "en",
          "data-loading": "lazy",
          "crossorigin": "anonymous",
          "async": "",
        };
        
        let giscusScript = document.createElement("script");
        Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
        document.body.appendChild(giscusScript);     </script>
    </body>
   </html>