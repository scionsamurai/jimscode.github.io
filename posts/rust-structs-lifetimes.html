<!doctype html>
<html lang="en-US" id="top-of-site">
 <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Discover the building blocks of Rust as we explore Structs and Lifetimes in-depth. From mastering struct design to unraveling lifetimes, this post equips system developers with essential knowledge for effective Rust programming.">
  <meta name="author" content="Jimmy Ruikka">
  <title>Rust Structs - JimsCode</title>
<script src='/txt/js/highlight.js'>
  </script>
  <link rel='stylesheet' href='/txt/css/monokaisublime.css' type="text/css">
<script>
hljs.highlightAll();  </script>
<script src='/txt/js/post.js'>
  </script>
<script src='/txt/js/site_funcs.js'>
  </script>
<script src='/txt/js/site_variables.js'>
  </script>
<script>
window.addEventListener('load', function() {
                var script = document.createElement('script');
                script.src = '/txt/js/ongenerated.js';
                document.body.appendChild(script);
              });  </script>
<script>
window.addEventListener('load', function() {
            var script = document.createElement('script');
            script.textContent = "setupTabs();addHeaderListeners();window.addEventListener('scroll', highlightActiveHeader);closeShareLinks(); updateCopyLinks();";
            document.body.appendChild(script);
          });  </script>
  <link rel='stylesheet' href='/txt/css/global.css' type="text/css">
  <link rel='stylesheet' href='/txt/css/post.css' type="text/css">
  <link rel='stylesheet' href='/txt/css/footer.css' type="text/css">
  <link rel='stylesheet' href='/txt/css/tabbedinfo.css' type="text/css">
  <link rel='stylesheet' href='/txt/css/flipcard.css' type="text/css">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="manifest" href="/images/site.webmanifest">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-HKH81XKEQN">
   </script>
<script>
window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-HKH81XKEQN');   </script>
  </head>
  <body>
   <input class="nodisplay" type="checkbox" id="sidebar_checkbox">
   <input class="nodisplay" type="radio" id="night" name="themecolor" value="night" onclick="updateThemeCache">
   <input onclick="updateThemeCache" class="nodisplay" type="radio" id="day" name="themecolor" value="day" checked="checked">
   <div class="wrapper">
    <div id="lsi29hle7j">
<span role="navigation" style="display:flex; background: var(--primary); justify-content: space-between; padding: 1rem 0; position: relative; z-index: 5; width: 100vw; min-height: 1.2rem;" class="navbar" id="navID" data-original-css="display:flex; background: var(--primary); justify-content: space-between; padding: 1rem 0; position: relative; z-index: 5; width: 100vw; min-height: 1.2rem;">     <div style="padding: 0 8px;" class="name-and-icon" data-original-css="padding: 0 8px;">
      <div class="sidebar_checkbox_hack">
       <label for="sidebar_checkbox" onclick="window.scrollTo(0,0)" class="sidebar_button pointer">       <p class="emoji_active_memo">Back to Post</p>
       <img src="/images/favicon-32x32.png" alt="Jims emoji icon">
</label>
      </div>
 <a href="/" style="text-decoration: none;" class="home-link" data-original-css="text-decoration: none;"><span style="width: auto; margin: 0; margin-left: 2rem; font-size: 1.35rem; color: black !important;" data-original-css="width: auto; margin: 0; margin-left: 2rem; font-size: 1.35rem; color: black !important;">Jims Code Blog</span></a>      </div>
     <div role="search" style="margin: auto 2rem auto 0;" class="navbar_right" id="search_area" data-original-css="margin: auto 2rem auto 0;">
      <form method="get" action="http://www.google.com/search" class="no-js-search">
       <input type="text" name="q" size="15" class="no-js-search__input" id="search">
       <button type="submit" value="Search!" class="no-js-search__button">
Search       </button>
       <input type="checkbox" name="sitesearch" value="jimscode.blog" checked="" style="display: none;" class="no-js-search__checkbox" data-original-css="display: none;">
      </form>
     </div>
</span>     <div class="color-pallete">
      <label for="night"></label>
      <label for="day"></label>
     </div>
     <div style="position: fixed;" id="star-area" data-original-css="position: fixed;">
     </div>
 <a href="#top-of-site" aria-label="Scroll to top" onclick="window.scrollTo(0,0)" onkeypress="if(event.keyCode===13){window.scrollTo(0,0)}" tabindex="0" style="background: var(--font-color); position: fixed; bottom: 2rem; left: 1rem; height: 3rem; width: 3rem; border-radius:5rem; text-align: center; z-index: 4; display: none;" class="pointer" id="arrow-div-id" data-original-css="background: var(--font-color); position: fixed; bottom: 2rem; left: 1rem; height: 3rem; width: 3rem; border-radius:5rem; text-align: center; z-index: 4; display: none;" data-conditional-scroll=" this.scrollY > 650:::display-block\|/">     <div style="width: 1rem; height: 1rem; border: solid var(--primary-clicked); border-width: 0 3px 3px 0; margin-top: 1rem;" class="up arrow" id="backToTopArrow" data-original-css="width: 1rem; height: 1rem; border: solid var(--primary-clicked); border-width: 0 3px 3px 0; margin-top: 1rem;">
     </div>
     <p style="display: none;" id="TopArrowText" data-original-css="display: none;">Back to top</p>
</a>     </div>
    <div id="lsi29hleyy">
     <div style="min-height: 20rem" class="banner-div" data-original-css="min-height: 20rem">
      <div class="banner">
      </div>
     </div>
     <div role="main" class="main-content">
      <div class="post-container">
       <div class="post">
        <h1 style="display: inline-flex; justify-content: space-around; text-align: center;" class="threedtext" data-original-css="display: inline-flex; justify-content: space-around; text-align: center;">Structuring Success: A Comprehensive Guide to Rust's Structs and Lifetimes</h1>
        <p style="font-size: 0.95rem;" data-original-css="font-size: 0.95rem;">Published: Sun, Feb 11 2024 14:18:59 GMT</p>
        <picture class="banner_picture" id="lsi29hljdp">
         <source srcset="/images/rust-structs-lifetimes-banner.webp" type="image/webp" class="banner-image">
          <source srcset="/images/rust-structs-lifetimes-banner-png.png" type="image/png" class="banner-image">
           <img src="" alt="Image of a stone built rock structure with buildings built out of the sides and on top of the structure." class="banner-image">
          </picture>
          <br>
          <div id="lsi29hlj7g">
<span id="lsi29hlsld">           <br>
           <h2 id="Introduction-to-Structs" class="pointer">Introduction to Structs<span class="anchor-image">⚓</span></h2>
           <br>
           <p>Structs are one of the most common and useful features in Rust. As we dive deeper into systems programming with Rust, understanding structs is essential. In this section, we will cover:</p>
           <br>
           <h3>What are Structs?</h3>
           <br>
           <p>Structs are custom data types that enable you to name and organize related data under one roof. Here is a basic example of defining a struct:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29hm3c3">struct BlogPost {
     title: String,
     author: String,
     content: String,
     published: bool
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>This struct <span class="special_quote">BlogPost</span> groups together all the data needed for a blog post - the title, author, content, and publish status.</p>
           <br>
           <p>Some key notes about structs:</p>
           <ul class="ul_class">
            <li>They allow you to represent complex real-world concepts in your code.</li>
            <li>The data inside structs is called "fields".</li>
            <li>Fields have a name and type.</li>
            <li>The whole struct data is grouped under one name ( <span class="special_quote">BlogPost</span> here).</li>
           </ul>
           <br>
           <p>In other words, structs allow us to create custom reusable data types, helping write easy-to-understand code.</p>
           <br>
           <h3>Why Use Structs?</h3>
           <br>
           <p>Here are some of the main reasons to use structs in Rust:</p>
           <ul class="ul_class">
            <li> <strong>Organization</strong> - Group related data together cleanly instead of separate variables</li>
            <li> <strong>Readability</strong> - Code is more understandable with descriptive struct names</li>
            <li> <strong>Reusability</strong> - Define a struct once and instantiate it multiple times</li>
            <li> <strong>Abstraction</strong> - Hide implementation details behind a simple struct interface</li>
            <li> <strong>Domain modeling</strong> - Directly map real concepts to code using data structures</li>
           </ul>
           <br>
           <p>For example, we can define a struct <span class="special_quote">User</span> to nicely model a user concept in code. And we can instantiate new <span class="special_quote">User</span> objects multiple times for each new user.</p>
           <br>
           <h3>Creating and Using Structs</h3>
           <br>
           <p>Defining a struct only creates a new type. To use it, we must create an <em>instance</em> .</p>
           <br>
           <p>Here is an example of creating a <span class="special_quote">BlogPost</span> instance and accessing its fields:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29hm3r2">let post = BlogPost {
     title: String::from("My First Post"),
     author: String::from("Dave"),
     content: String::from("Hello world!"),
     published: false
 };
 
 println!("Post title: {}", post.title); // Prints "My First Post"</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <h2 id="Struct-Methods" class="pointer">Struct Methods<span class="anchor-image">⚓</span></h2>
           <br>
           <p>We know how to declare and instantiate structs in Rust. But how do we add functionality to them? This is where struct methods come in handy.</p>
           <br>
           <h3>Attaching Methods to Structs</h3>
           <br>
           <p>In addition to data fields, we can define methods on structs to implement behavior. Here's an example:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29hm4fw">struct BlogPost {
    // existing fields
 }
 
 impl BlogPost {
     fn new(title: &amp;str, author: &amp;str) -&gt; BlogPost {
         BlogPost {
             title: String::from(title),
             author: String::from(author),
             content: String::new(),
             published: false
         }
     }
 
     fn publish(&amp;mut self) { // needed to make self mutable for method to change struct
         self.published = true;
     }
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>We use the <span class="special_quote">impl</span> block to add methods to the <span class="special_quote">BlogPost</span> struct. This should come after the struct definition.</p>
           <br>
           <p>Some notes on struct methods:</p>
           <ul class="ul_class">
            <li>The first method is a <strong>constructor</strong> named <span class="special_quote">new</span> to initialize a new instance</li>
            <li>Methods take a special first <span class="special_quote">self</span> argument</li>
            <li>We can modify state using <span class="special_quote">&amp;mut self</span> like <span class="special_quote">publish()</span> </li>
           </ul>
           <br>
           <p>Now we can create <span class="special_quote">BlogPost</span> instances via the constructor and call methods like <span class="special_quote">publish</span> :</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29hm4uv">let mut post = BlogPost::new("Post Title", "Author Name");
  //^ needed to make struct mutable to avoid error on publish method
 
 post.publish();
 println!("Post published: {}", post.pusblished); // Post published: true</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <h3>Associated Functions</h3>
           <br>
           <p>We can also add functions inside <span class="special_quote">impl</span> blocks that <em>don't</em> take a <span class="special_quote">self</span> argument. These are called <strong>associated functions</strong> :</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29hm43q">impl BlogPost {
    fn new() {
        // ...
    }
 
    fn sample() -&gt; BlogPost {
         BlogPost::new("Sample", "Claude")
     }
 }
 
 let new_post = BlogPost::sample();
 println!("new_post title: {}", new_post.title); // new_post title: Sample</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>Associated functions act like static methods in other languages. We call them using double colons like <span class="special_quote">BlogPost::sample()</span> .</p>
           <br>
           <h2 id="Tuple-Structs" class="pointer">Tuple Structs<span class="anchor-image">⚓</span></h2>
           <br>
           <p>So far we've seen traditional structs that name all their fields. But Rust also allows us to define <strong>tuple structs</strong> which are similar to tuples.</p>
           <br>
           <h3>Tuple Structs vs Tuples</h3>
           <br>
           <p>Tuple structs may seem identical to tuples, but there are some key differences to keep in mind:</p>
           <br>
           <table>
            <thead>
             <tr>
              <th>
Feature              </th>
              <th>
Tuple Struct              </th>
              <th>
Tuple              </th>
             </tr>
            </thead>
            <tbody>
             <tr>
              <th>
Definition              </th>
              <th>
Uses the struct keyword with fields defined within curly braces <span class="special_quote">{...}</span> .              </th>
              <th>
Uses parentheses <span class="special_quote">()</span> to define.              </th>
             </tr>
             <tr>
              <th>
Naming              </th>
              <th>
Each field has a name.              </th>
              <th>
Elements don't have individual names.              </th>
             </tr>
             <tr>
              <th>
Typing              </th>
              <th>
Each field can have a different type.              </th>
              <th>
All elements must have the same type or each needs explicit type annotation.              </th>
             </tr>
             <tr>
              <th>
Use Cases              </th>
              <th>
Lightweight structures, multiple return values              </th>
              <th>
Temporary data storage, function arguments              </th>
             </tr>
            </tbody>
           </table>
           <br>
           <p>The main takeaway is that tuple structs create reusable custom types, while regular tuples simply group together values.</p>
           <br>
           <p>For example, a function returning <span class="special_quote">(bool, i32)</span> cannot name or type alias the return type. But by using a tuple struct like:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29hm4f8">struct FuncResult(bool, i32);
 
 fn my_func() -&gt; FuncResult {
     // ...
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>We can type alias the return into a neater custom type. Use regular tuples for temporary storage and tuple structs when you need a named, typed structure.</p>
           <br>
           <h3>Tuple Struct Syntax</h3>
           <br>
           <p>A tuple struct looks like this:</p>
           <br>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29hm4ae">struct Color(i32, i32, i32);
 
 let red = Color(255, 0, 0);</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>Instead of field names, it just has the types listed within the parentheses. We create instances like tuples too, without field names.</p>
           <br>
           <p>This offers lighter syntax when we know our struct will only have a small fixed set of fields.</p>
           <br>
           <h3>Use Cases for Tuple Structs</h3>
           <br>
           <p>Tuple structs come in handy for a few scenarios:</p>
           <br>
           <ul class="ul_class">
            <li> <strong>Points</strong> - A point in an n-dimensional space can be represented using a tuple struct:</li>
           </ul>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29hm4d1">struct Point(f32, f32, f32);
 
 let origin = Point(0.0, 0.0, 0.0);</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <ul class="ul_class" data-conditional-css="lsi29hm2oh:::\|/" style="">
            <li> <strong>Colors</strong> - As we saw earlier, RGB or other color models can be created using tuple structs.</li>
            <li> <strong>Return multiple values</strong> - Functions in Rust can only return one value. But by returning a tuple struct, we can logically return multiple values.</li>
           </ul>
           <br>
           <p>Overall, tuple structs trade field names for lighter syntax in cases where the meaning is still clear. They can be used for colors, points, key-value pairs and more. And they enable returning multiple values from functions.</p>
           <br>
           <h2 id="What-is-an-enum-in-Rust-" class="pointer">What is an enum in Rust?<span class="anchor-image">⚓</span></h2>
           <br>
           <p>Enums or enumerations in Rust allow you to define a type that can take on one of several possible values. Each value that an enum can take on is called a variant.</p>
           <br>
           <p>For example, we can define a simple enum to represent web application permissions:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29hm5vr">enum Permission {
     Read,
     Write,
     Admin
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>This Permission enum has three variants - Read, Write and Admin.</p>
           <br>
           <p>Now we can create variables of type <span class="special_quote">Permission</span> :</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29hm5rr">let permission = Permission::Read;</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>And we can use match statements to take different actions depending on the variant:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29hm5b4">fn check_permission(permission: Permission) {
     match permission {
         Permission::Read =&gt; println!("Can read!"),
         Permission::Write =&gt; println!("Can write!"),
         Permission::Admin =&gt; println!("Full access")
     }
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>Some key characteristics of enums:</p>
           <ul class="ul_class">
            <li>Enum variants can store data like structs</li>
            <li>When compiled, enums occupy only as much space as the largest variant</li>
            <li>Enums clarify code and make invalid states impossible</li>
            <li>Pattern matching on enums is exhaustive and enforced</li>
           </ul>
           <br>
           <p>Enums allow modeling distinct, meaningful cases in Rust code while enabling type safety through the compiler. They are essential in systems programming.</p>
           <br>
           <h2 id="Enums-and-Structs" class="pointer">Enums and Structs<span class="anchor-image">⚓</span></h2>
           <br>
           <p>Enums and structs are powerful data types on their own. But Rust also allows us to combine them together to create more tailored, flexible data modeling.</p>
           <br>
           <h3>Mixing Enums and Structs</h3>
           <br>
           <p>Consider we have a struct representing a user:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29hm5da">struct User {
     id: i32,
     name: String,
     email: String
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>And we want to model different types of users like admins, managers etc. We can achieve this using an enum connected to appropriate structs:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29hm50v">enum UserType {
     Admin(User),
     Manager(User),
     Guest(User)
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>Now we can instantiate <span class="special_quote">UserType</span> variants that contain specialized <span class="special_quote">User</span> data:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29hm52i">let admin = UserType::Admin(User {
     id: 1,
     name: String::from("John"),
     email: String::from("john@company.com")
 });</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>So <span class="special_quote">UserType</span> wraps a <span class="special_quote">User</span> adding more context. We can access inner user data using struct destructuring:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29hm53y">match user_type {
    UserType::Admin(user) =&gt; {
       println!("Admin user: {}", user.name)
    },
    // ...
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <h3>Benefits of Connecting Enums and Structs</h3>
           <br>
           <p>Some benefits of this pattern include:</p>
           <ul class="ul_class">
            <li>Reuse existing structs (DRY)</li>
            <li>Add context/meaning through enums</li>
            <li>Cleaner domain modeling in code</li>
            <li>Share common struct methods across enum variants</li>
            <li>Type safety with specialized enum variants</li>
           </ul>
           <br>
           <p>So in systems programming, combining enums and structs allows us to build complex, contextual data models.</p>
           <br>
           <h2 id="Lifetimes-in-Rust" class="pointer">Lifetimes in Rust<span class="anchor-image">⚓</span></h2>
           <br>
           <p>Lifetimes play a major role in Rust's ownership and borrowing system. When writing unsafe code or non-trivial data structures, understanding lifetimes is essential to ensuring memory safety.</p>
           <br>
           <h3>What is a Lifetime?</h3>
           <br>
           <p>A lifetime denotes the scope for which a reference is valid. For example:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29hm5ha">{
     let x = 10;
     let ref = &amp;x; // ~~ref~~ has the lifetime of ~~x~~
 }
 // ~~x~~ goes out of scope here so ~~ref~~ cannot be used</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>By having lifetimes attached to references, Rust ensures they never outlive the data they refer to.</p>
           <br>
           <h3>Example: Lifetimes in Practice</h3>
           <br>
           <p>To see how lifetimes prevent dangling references, let's walk through this example:</p>
           <br>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29hm5du">let r;
 
 {
 let x = 5;
 
 r = &amp;x; // r is a reference to x
 } // x goes out of scope here and is deallocated
 
 println!("{}", r);</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>This code tries to create a reference <span class="special_quote">r</span> to <span class="special_quote">x</span> and use it after <span class="special_quote">x</span> has been deallocated. When we try to compile it:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-shell" id="lsi29hm51u">error[E0597]: "x" does not live long enough
   --&gt; src/main.rs:7:5
    |
 6  |         r = &amp;x;
    |              - borrow occurs here
 7  |     } // "x" dropped here while still borrowed
 8  |
 9  |     println!("{}", r);
    |                    ^ borrowed value does not live long enough</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">shell</span></span></pre>
           <br>
           <p>The compiler shows accurately that <span class="special_quote">r</span> is borrowing some data that does not live long enough. So it disallows this code.</p>
           <br>
           <p>The lifetime of <span class="special_quote">x</span> ends after the inner scope it was created in. But <span class="special_quote">r</span> tries to access it outside that scope. By having lifetime logic built-in, Rust saves us from subtle bugs.</p>
           <br>
           <h3>Preventing Dangling References</h3>
           <br>
           <p>The main purpose of lifetimes is preventing <strong>dangling references</strong> . This happens when you have a reference to some data, but that data has been deallocated. The reference effectively points to nothing and using it would be unsafe.</p>
           <br>
           <p>For example, consider a struct holding references:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29hm5bv">struct Foo {
     data: &amp;i32
 }
 
 let x = 10;
 let foo = Foo { data: &amp;x }; // borrow ~~x~~
 
 drop(x); // deallocate ~~x~~
 println!("{}", foo.data); // danger!</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>Lifetimes avoid this by tying struct members to the lifetime of their owners.</p>
           <br>
           <p>Overall, lifetime syntax adds complexity but provides essential memory safety. Ignoring lifetimes can cause hard to trace bugs and crashes.</p>
           <br>
           <h3>Lifetime Annotations</h3>
           <br>
           <p>Rust is able to infer lifetimes in many cases. But for certain structures containing references, we need to provide lifetime annotations to compile:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29hm6ze">struct Foo { // Won't compile!
     data: &amp;i32
 }
 
 fn make_foo(x: &amp;i32) -&gt; Foo {
     Foo { data: x }
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>This errors:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-shell" id="lsi29hm64h">error[E0106]: missing lifetime specifier
  --&gt; src/main.rs:2:15
   |
 2 |     data: &amp;i32
   |               ^ expected lifetime parameter</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">shell</span></span></pre>
           <br>
           <p>The compiler can't tell how long <span class="special_quote">Foo</span> should live just from this code. We need to add an annotation that <span class="special_quote">Foo</span> instances live only as long as what they reference:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29hm6dk">struct Foo&lt;'a&gt; {
     data: &amp;'a i32
 }
 
 fn make_foo(x: &amp;i32) -&gt; Foo {
     Foo { data: x }
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>Now it compiles correctly. Lifetimes are usually inferred but required in struct and enum definitions if they hold references. These annotations clarify for Rust the relationships between the struct, its owner, and the references it holds.</p>
           <br>
           <h3>Lifetimes in Structs</h3>
           <br>
           <p>Structs holding references also need lifetime annotations to ensure memory safety. For example:</p>
<pre class="hljs-pre" style="position: relative;"><code class="hljs language-rust" id="lsi29hm69w">struct CustomString&lt;'a&gt; {
     text: &amp;'a str,
 }
 
 fn main() {
     let variable1 = String::from("This is a string");
 
     let x = CustomString {
         text: variable1.as_str()
     };
 }</code><span class="hljs__link_and_copy nodisplay"><span class="link_and_copy__copy_link pointer">⎘&nbsp;</span><span class="link_and_copy__text">rust</span></span></pre>
           <br>
           <p>This models a string struct holding a reference to some text. Now, <span class="special_quote">x</span> cannot outlive <span class="special_quote">variable1</span> due to Rust's lifetime rules.</p>
           <br>
           <p>When <span class="special_quote">variable1</span> goes out of scope at the end of <span class="special_quote">main()</span> , the reference inside <span class="special_quote">x</span> would be invalidated. So the compiler ensures <span class="special_quote">x</span> also goes out of scope with <span class="special_quote">variable1</span> .</p>
           <br>
           <p>If we tried to return <span class="special_quote">x</span> from <span class="special_quote">main</span> , we would get an error that <span class="special_quote">'variable1</span> does not live long enough. The annotation in the struct definition ties the struct's lifetime to its inner reference.</p>
           <br>
           <p>Lifetimes apply transitively from structs to their fields to ensure no reference outlives what it points to. This protects memory safety.</p>
           <br>
           <h2 id="Recap-and-Next-Steps" class="pointer">Recap and Next Steps<span class="anchor-image">⚓</span></h2>
           <br>
           <p>We've covered fundamental concepts around structs and lifetimes in Rust that empower building complex data structures safely. Let's recap the key takeaways:</p>
           <br>
           <h3>Custom Data Modeling is Key</h3>
           <ul class="ul_class">
            <li>Structs allow custom data types for concise, self-documenting code</li>
            <li>Enums handle variants elegantly with exhaustive checking</li>
            <li>Generics enable reusing structures across types</li>
            <li>Annotations make relationships clear to compiler</li>
           </ul>
           <br>
           <p>Rust really shines in flexibly modeling concepts in code.</p>
           <br>
           <h3>Memory Safety Without Garbage Collection</h3>
           <ul class="ul_class">
            <li>Ownership and borrowing enable access control</li>
            <li>Lifetimes eliminate dangling reference bugs</li>
            <li>Struct design affects encapsulation</li>
           </ul>
           <br>
           <p>So Rust flips tradeoffs in systems programming - no GC overhead but memory is still safe!</p>
           <br>
           <h3>Just the Beginning...</h3>
           <p>We covered a lot of ground, but so much more exists:</p>
           <ul class="ul_class">
            <li>Advanced enum techniques</li>
            <li>Generic struct constraints</li>
            <li>Optimizing performance with struct layouts</li>
            <li>Concurrency patterns like message passing architectures</li>
            <li>Graph data structures with references</li>
           </ul>
           <br>
           <p>I aimed to provide a solid starting point to exploring these topics more. Systems programming with Rust is an exciting journey!</p>
           <br>
</span>          </div>
          <div style="display: flex; justify-content: space-around; margin-bottom: 1rem;" class="prev_next_buttons" data-original-css="display: flex; justify-content: space-around; margin-bottom: 1rem;">
<span style="display: block;" class="prev_button" data-original-css="display: block;"> <a href="/posts/rust-principles" class="btn-cta pad">Previous Post</a> </span><span style="display: block;" class="next_button" data-original-css="display: block;"> <a href="/posts/rust-enums" class="btn-cta pad">Next Post</a> </span>          </div>
          <p></p>
          <div class="giscus">
          </div>
          <p></p>
         </div>
         <div class="share-links">
          <div id="lsi29hlll0">
           <label for="share-toggle" class="btn-cta" id="share-btn">Share <span class="share_post_text">post?</span> </label>
           <input type="checkbox" id="share-toggle">
           <ul id="share-links">
            <li style="list-style: none;" data-original-css="list-style: none;"> <a href="https://www.facebook.com/sharer/sharer.php?u=https://www.jimscode.blog/posts/rust-structs-lifetimes" target="_blank">Facebook</a> </li>
            <li style="list-style: none;" data-original-css="list-style: none;"> <a href="https://twitter.com/intent/tweet?url=https://www.jimscode.blog/posts/rust-structs-lifetimes" target="_blank">Twitter</a> </li>
            <li style="list-style: none;" data-original-css="list-style: none;"> <a href="https://www.linkedin.com/shareArticle?url=https://www.jimscode.blog/posts/rust-structs-lifetimes" target="_blank">LinkedIn</a> </li>
            <li style="list-style: none;" data-original-css="list-style: none;"> <a href="https://pinterest.com/pin/create/button/?url=https://www.jimscode.blog/posts/rust-structs-lifetimes&amp;media=https://www.jimscode.blog/images/rust-structs-lifetimes-banner-png.png&amp;description=structuring%20success%20a%20comprehensive%20guide%20to%20rusts%20structs%20and%20lifetimes" target="_blank">Pinterest</a> </li>
            <li style="list-style: none;" data-original-css="list-style: none;"> <a href="https://www.reddit.com/submit?url=https://www.jimscode.blog/posts/rust-structs-lifetimes" target="_blank">Reddit</a> </li>
            <li style="list-style: none;" data-original-css="list-style: none;"> <a href="whatsapp://send?text=https://www.jimscode.blog/posts/rust-structs-lifetimes" target="_blank">WhatsApp</a> </li>
            <li style="list-style: none;" data-original-css="list-style: none;"> <a href="mailto:?subject=structuring%20success%20a%20comprehensive%20guide%20to%20rusts%20structs%20and%20lifetimes&amp;body=https://www.jimscode.blog/posts/rust-structs-lifetimes" target="_blank">Email</a> </li>
            <li style="list-style: none;" data-original-css="list-style: none;"> <a href="https://www.instagram.com/share?url=https://www.jimscode.blog/posts/rust-structs-lifetimes" target="_blank">Instagram</a> </li>
           </ul>
           <br>
          </div>
         </div>
        </div>
        <aside class="sidebar">
         <br>
         <div class="about-me">
          <br>
          <div class="avatar-container">
           <img data-src="https://www.gravatar.com/avatar/26b9ca4353165489beae792f2aea7b21?s=250" alt="Avatar" class="profile-picture" src="https://www.gravatar.com/avatar/26b9ca4353165489beae792f2aea7b21?s=250">
          </div>
          <p class="large-text">About: <a class="btn-cta pad" href="/authors/jimmy-ruikka">Jimmy Ruikka</a> </p>
          <hr>
          <p style="font-size: 14px;" data-original-css="font-size: 14px;">Within the realm of technology and innovation, a passionate individual emerges! Join the creator of JimsCode.Blog as he unravels the realms of technology.</p>
         </div>
         <br>
         <div class="about-post">
          <p class="large-text">Tags</p>
          <hr>
          <ul id="lsi29hli9f" style="display: contents; line-height: 2rem;">
           <li id="tagVar_rust" class="tagVar" style="display: contents; line-height: 2rem;"> <a href="/tags/rust" class="btn-cta">rust</a> </li>
           <li id="tagVar_system dev" class="tagVar" style="display: contents; line-height: 2rem;"> <a href="/tags/system%20dev" class="btn-cta">system dev</a> </li>
           <li id="tagVar_structs" class="tagVar" style="display: contents; line-height: 2rem;"> <a href="/tags/structs" class="btn-cta">structs</a> </li>
          </ul>
          <br>
         </div>
         <div class="headers">
          <div role="navigation" id="toc">
           <h3>In this article</h3>
           <hr>
           <nav aria-label="Table of Contents">
            <ul role="list">
             <li style="display: block;" role="listitem"> <a class="nav-link" tabindex="0" href="#Introduction-to-Structs">Introduction to Structs</a> </li>
             <hr>
             <li style="display: block;" role="listitem"> <a class="nav-link" tabindex="0" href="#Struct-Methods">Struct Methods</a> </li>
             <hr>
             <li style="display: block;" role="listitem"> <a class="nav-link" tabindex="0" href="#Tuple-Structs">Tuple Structs</a> </li>
             <hr>
             <li style="display: block;" role="listitem"> <a class="nav-link" tabindex="0" href="#What-is-an-enum-in-Rust-">What is an enum in Rust?</a> </li>
             <hr>
             <li style="display: block;" role="listitem"> <a class="nav-link" tabindex="0" href="#Enums-and-Structs">Enums and Structs</a> </li>
             <hr>
             <li style="display: block;" role="listitem"> <a class="nav-link" tabindex="0" href="#Lifetimes-in-Rust">Lifetimes in Rust</a> </li>
             <hr>
             <li style="display: block;" role="listitem"> <a class="nav-link" tabindex="0" href="#Recap-and-Next-Steps">Recap and Next Steps</a> </li>
            </ul>
           </nav>
          </div>
          <div class="affiliate">
           <h3>Affiliate links</h3>
           <p>Check out this great product: <a href="#">Product Name</a> </p>
           <div id="lsi29hloo2">
            <p>sidebar</p>
           </div>
          </div>
         </div>
        </aside>
       </div>
      </div>
      <div id="lsi29hlep7">
       <footer role="contentinfo" style="padding: 20px; text-align: center;" data-original-css="padding: 20px; text-align: center;">
        <br>
        <br>
        <div class="footer-content">
         <div class="footer-section">
          <h4>About</h4>
          <p style="font-size: 0.9rem;" data-original-css="font-size: 0.9rem;">Embark on a coding journey with Jims Code Blog - your go-to destination for insightful tutorials, innovative projects, and the latest trends in the dynamic world of software development.</p>
         </div>
         <div class="footer-section">
          <h4>Contact</h4>
          <p>Email: admin@jimscode.blog</p>
         </div>
         <ul class="footer-section" id="lsi29hmfrr">
          <li style="list-style: none;" data-original-css="list-style: none;"> <a href="/about-us">About Us</a> </li>
          <li style="list-style: none;" data-original-css="list-style: none;"> <a href="/privacy-policy">Privacy Policy</a> </li>
          <li style="list-style: none;" data-original-css="list-style: none;"> <a href="/terms-of-service">Terms of Service</a> </li>
         </ul>
         <div class="footer-disclaimer">
          <p style="font-size: 0.82rem;" data-original-css="font-size: 0.82rem;"> <strong>Disclaimer:</strong> The information provided on this blog is for educational and informational purposes related to coding and software development. We do not guarantee the accuracy, completeness, or reliability of any information presented. Readers are encouraged to conduct their own research, practice due diligence, and consult with professionals for coding-related decisions and implementation.</p>
         </div>
         <div class="footer-bottom">
          <p>Portions of this website use <a href="https://highlightjs.org">highlight.js</a> , © 2023 Jims Code Blog</p>
         </div>
        </div>
       </footer>
      </div>
<style>
@media only screen and (max-width : 1350px) and (min-width : 950px) {
#arrow-div-id{ right: 2.2rem; left: unset !important;}
}

@media only screen and (max-width : 750px) {
#arrow-div-id{ display: none !important;}#lsi29hmfrr{ font-size: 0.9rem; display: flex; justify-content: space-between; padding: 5px 0 5px 0;}
}

@media only screen and (max-width : 1350px) {
#TopArrowText{ right: 1rem;}
}

@media only screen and (min-width : 1px) {
#lsi29hljdp{ display: block;}#lsi29hli9f{ display: block;}
}

@media only screen and (min-width : 750px) {
#lsi29hmfrr{ display: flex; flex-direction: column;}
}      </style>
     </div>
<script>
toggle_nightmode();loadThemeCache();generateSearchElements('search_area'); updateComments();     </script>
<script>
let giscusTheme = localStorage.getItem("theme");
        let giscusAttributes = {
          "src": "https://giscus.app/client.js",
          "data-repo": "scionsamurai/jimscode.github.io",
          "data-repo-id": "R_kgDOK8_rSw",
          "data-category": "Announcements",
          "data-category-id": "DIC_kwDOK8_rS84Cb9LP",
          "data-mapping": "pathname",
          "data-strict": "1",
          "data-reactions-enabled": "1",
          "data-emit-metadata": "0",
          "data-theme": giscusTheme && giscusTheme == "night" ? "noborder_gray" : "noborder_light",
          "data-lang": "en",
          "data-loading": "lazy",
          "crossorigin": "anonymous",
          "async": "",
        };
        
        let giscusScript = document.createElement("script");
        Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
        document.body.appendChild(giscusScript);     </script>
    </body>
   </html>